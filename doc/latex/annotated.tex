\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1algorithm_1_1Algorithm}{ea\+::algorithm\+::\+Algorithm}} \\*The base class of (E$\vert$G)A search algorithms }{\pageref{classea_1_1algorithm_1_1Algorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1algorithm_1_1AlgorithmStatistics}{ea\+::algorithm\+::\+Algorithm\+Statistics}} \\*Statistics of rho-\/backdoor search }{\pageref{structea_1_1algorithm_1_1AlgorithmStatistics}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1BestSelector}{ea\+::method\+::\+Best\+Selector}} \\*Selects instances by their fitness }{\pageref{classea_1_1method_1_1BestSelector}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1CartesianRBSearch}{core\+::solve\+::\+Cartesian\+R\+B\+Search}} \\*Searches for multiple rho-\/backdoors with the specified parameters and then performs cartesian product of non-\/conflicting sets. Finally, only non-\/conflicting assumptions from the cartesian product are included in the resulting search }{\pageref{classcore_1_1solve_1_1CartesianRBSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1search_1_1CartesianSearch}{core\+::search\+::\+Cartesian\+Search}} \\*The class used to search through the cartesian product of custom searches }{\pageref{classcore_1_1search_1_1CartesianSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1ConjLimit}{ea\+::limit\+::\+Conj\+Limit}} \\*Conjunction of a set of limits }{\pageref{classea_1_1limit_1_1ConjLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1Crossover}{ea\+::method\+::\+Crossover}} \\*\mbox{\hyperlink{classea_1_1method_1_1Crossover}{Crossover}} method interface }{\pageref{classea_1_1method_1_1Crossover}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1DoerrMutation}{ea\+::method\+::\+Doerr\+Mutation}} \\*Doerr-\/optimized mutation }{\pageref{classea_1_1method_1_1DoerrMutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1algorithm_1_1EAAlgorithm}{ea\+::algorithm\+::\+E\+A\+Algorithm}} \\*Evolutionary (1+1) algorithm }{\pageref{classea_1_1algorithm_1_1EAAlgorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1instance_1_1Fitness}{ea\+::instance\+::\+Fitness}} \\*This structure represents Instances\textquotesingle{} fitness. It is calculated as rho $\ast$ 2$^\wedge$\{size\} + (1 -\/ \textbackslash{}rho) $\ast$ 2$^\wedge$\{pow\+\_\+nr\} if this can be effectively represented in built-\/in types }{\pageref{structea_1_1instance_1_1Fitness}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1FitnessLimit}{ea\+::limit\+::\+Fitness\+Limit}} \\*This limit controls execution by comparing best fitness with the specified limit }{\pageref{classea_1_1limit_1_1FitnessLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1search_1_1FullSearch}{core\+::search\+::\+Full\+Search}} \\*The class used to perform full search }{\pageref{classcore_1_1search_1_1FullSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1algorithm_1_1GAAlgorithm}{ea\+::algorithm\+::\+G\+A\+Algorithm}} \\*Genetic algorithm }{\pageref{classea_1_1algorithm_1_1GAAlgorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1instance_1_1Instance}{ea\+::instance\+::\+Instance}} \\*This class represents (E$\vert$G)A instance used in this project }{\pageref{classea_1_1instance_1_1Instance}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1Limit}{ea\+::limit\+::\+Limit}} \\*This is an interface for all limits that control the execution of an algorithm }{\pageref{classea_1_1limit_1_1Limit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1MapleCOMSPSSolver}{core\+::sat\+::solver\+::\+Maple\+C\+O\+M\+S\+P\+S\+Solver}} \\*Painless-\/adapted \mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1MapleCOMSPSSolver}{Maple\+C\+O\+M\+S\+P\+S\+Solver}} solver implementation }{\pageref{classcore_1_1sat_1_1solver_1_1MapleCOMSPSSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1Mutation}{ea\+::method\+::\+Mutation}} \\*\mbox{\hyperlink{classea_1_1method_1_1Mutation}{Mutation}} interface }{\pageref{classea_1_1method_1_1Mutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1NaiveSolve}{core\+::solve\+::\+Naive\+Solve}} \\*Uses the specified native solver to solve the problem }{\pageref{classcore_1_1solve_1_1NaiveSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1OnePointCrossover}{ea\+::method\+::\+One\+Point\+Crossover}} \\*Standard one-\/point crossover }{\pageref{classea_1_1method_1_1OnePointCrossover}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1OneRBSearch}{core\+::solve\+::\+One\+R\+B\+Search}} \\*Searches for rho-\/backdoor with the specified parameters }{\pageref{classcore_1_1solve_1_1OneRBSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1PainlessSolver}{core\+::sat\+::solver\+::\+Painless\+Solver}} \\*Painless-\/based \mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{Solver}} implementation }{\pageref{classcore_1_1sat_1_1solver_1_1PainlessSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1prop_1_1ParProp}{core\+::sat\+::prop\+::\+Par\+Prop}} \\*Parallel propagation implementation }{\pageref{classcore_1_1sat_1_1prop_1_1ParProp}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1PointsLimit}{ea\+::limit\+::\+Points\+Limit}} \\*This limit controls the execution by limiting the inaccurate number of points visited }{\pageref{classea_1_1limit_1_1PointsLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1preprocess_1_1Preprocess}{ea\+::preprocess\+::\+Preprocess}} \\*The class managing sat formula preprocessing and (E$\vert$G)A heuristics }{\pageref{structea_1_1preprocess_1_1Preprocess}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1Problem}{core\+::sat\+::\+Problem}} \\*The problem descriptor class }{\pageref{classcore_1_1sat_1_1Problem}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1prop_1_1Prop}{core\+::sat\+::prop\+::\+Prop}} \\*S\+AT Propagation interface }{\pageref{classcore_1_1sat_1_1prop_1_1Prop}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1search_1_1RandomSearch}{core\+::search\+::\+Random\+Search}} \\*The class used to perform random search }{\pageref{classcore_1_1search_1_1RandomSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1RBSearch}{core\+::solve\+::\+R\+B\+Search}} \\*Class used to reduce S\+AT problems to a set of independent tasks }{\pageref{classcore_1_1solve_1_1RBSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1RecurringReduceSolve}{core\+::solve\+::\+Recurring\+Reduce\+Solve}} \\*This implementation acts as follows\+: }{\pageref{classcore_1_1solve_1_1RecurringReduceSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1ReduceSolve}{core\+::solve\+::\+Reduce\+Solve}} \\*The base class for all algorithms that use rho-\/backdoor search reduction }{\pageref{classcore_1_1solve_1_1ReduceSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1ResourceLimit}{ea\+::limit\+::\+Resource\+Limit}} \\*This limit controls the execution by limiting time and memory consumption of an algorithm }{\pageref{classea_1_1limit_1_1ResourceLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1instance_1_1SharedData_1_1SamplingConfig}{ea\+::instance\+::\+Shared\+Data\+::\+Sampling\+Config}} \\*Sampling configuration }{\pageref{structea_1_1instance_1_1SharedData_1_1SamplingConfig}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1search_1_1Search}{core\+::search\+::\+Search}} \\*The class representing the sequential search in assignments space }{\pageref{classcore_1_1search_1_1Search}}{}
\item\contentsline{section}{\mbox{\hyperlink{structcore_1_1domain_1_1SearchSpace}{core\+::domain\+::\+Search\+Space}} \\*The class representing the search space for S\+AT assumptions }{\pageref{structcore_1_1domain_1_1SearchSpace}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1Selector}{ea\+::method\+::\+Selector}} \\*Performs instance selection }{\pageref{classea_1_1method_1_1Selector}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1SequentialSolverService}{core\+::sat\+::solver\+::\+Sequential\+Solver\+Service}} \\*The solver service managing multiple sequential solvers }{\pageref{classcore_1_1sat_1_1solver_1_1SequentialSolverService}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1sharing_1_1Shareable}{core\+::sat\+::sharing\+::\+Shareable}} \\*The interface of methods that are able to share clauses }{\pageref{classcore_1_1sat_1_1sharing_1_1Shareable}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1instance_1_1SharedData}{ea\+::instance\+::\+Shared\+Data}} \\*This struct is shared between all instances under the same algorithm }{\pageref{structea_1_1instance_1_1SharedData}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1sharing_1_1Sharing}{core\+::sat\+::sharing\+::\+Sharing}} \\*The class responsible for clause sharing }{\pageref{classcore_1_1sat_1_1sharing_1_1Sharing}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1prop_1_1SimpProp}{core\+::sat\+::prop\+::\+Simp\+Prop}} \\*Minisat-\/based propagation engine implementation }{\pageref{classcore_1_1sat_1_1prop_1_1SimpProp}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1SimpSolver}{core\+::sat\+::solver\+::\+Simp\+Solver}} \\*M\+S\+\_\+\+NS\+:Simp\+Solver-\/based \mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{Solver}} implementation }{\pageref{classcore_1_1sat_1_1solver_1_1SimpSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1SingleReduceSolve}{core\+::solve\+::\+Single\+Reduce\+Solve}} \\*This implementation simply solves problems generated by reduction }{\pageref{classcore_1_1solve_1_1SingleReduceSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1search_1_1SingleSearch}{core\+::search\+::\+Single\+Search}} \\*The search implementation consisting of only one (empty) assignment }{\pageref{classcore_1_1search_1_1SingleSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1Solve}{core\+::solve\+::\+Solve}} \\*The core class that performs all actions related to solving S\+AT }{\pageref{classcore_1_1solve_1_1Solve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{core\+::sat\+::solver\+::\+Solver}} \\*S\+AT \mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{Solver}} interface }{\pageref{classcore_1_1sat_1_1solver_1_1Solver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1SolverService}{core\+::sat\+::solver\+::\+Solver\+Service}} \\*S\+AT solver service used to asynchronously execute sequential solvers with specified time limits }{\pageref{classcore_1_1sat_1_1solver_1_1SolverService}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1StallLimit}{ea\+::limit\+::\+Stall\+Limit}} \\*This limit controls execution by limiting the number of same instances (by count or by time) }{\pageref{classea_1_1limit_1_1StallLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1TwoPointCrossover}{ea\+::method\+::\+Two\+Point\+Crossover}} \\*Standard two-\/point crossover }{\pageref{classea_1_1method_1_1TwoPointCrossover}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1UniformMutation}{ea\+::method\+::\+Uniform\+Mutation}} \\*Standard uniform mutation }{\pageref{classea_1_1method_1_1UniformMutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1search_1_1UniqueSearch}{core\+::search\+::\+Unique\+Search}} \\*The class used to perform unique random search. Used for small sets of variables }{\pageref{classcore_1_1search_1_1UniqueSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{structcore_1_1domain_1_1Vars}{core\+::domain\+::\+Vars}} \\*The class representing variables set. Variables are meant as keys in variable mapping \mbox{\hyperlink{classcore_1_1domain_1_1VarView}{core\+::domain\+::\+Var\+View}} }{\pageref{structcore_1_1domain_1_1Vars}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1VarView}{core\+::domain\+::\+Var\+View}} \\*The class representing variable mapping. Is used to compactly represent mapping from a chosen set of variables }{\pageref{classcore_1_1domain_1_1VarView}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1solve_1_1WithPainlessSolve}{core\+::solve\+::\+With\+Painless\+Solve}} }{\pageref{classcore_1_1solve_1_1WithPainlessSolve}}{}
\end{DoxyCompactList}
