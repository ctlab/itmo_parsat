\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1algorithm_1_1Algorithm}{ea\+::algorithm\+::\+Algorithm}} \\*The base class of (E$\vert$G)A search algorithms }{\pageref{classea_1_1algorithm_1_1Algorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1AssignmentModifier}{core\+::domain\+::\+Assignment\+Modifier}} \\*The base class for searches that step by modifying assignment }{\pageref{classcore_1_1domain_1_1AssignmentModifier}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1BestSelector}{ea\+::method\+::\+Best\+Selector}} \\*Selects instances by their fitness }{\pageref{classea_1_1method_1_1BestSelector}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1CartesianSearch}{core\+::domain\+::\+Cartesian\+Search}} \\*The class used to search through the cartesian product of custom searches }{\pageref{classcore_1_1domain_1_1CartesianSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1ConjLimit}{ea\+::limit\+::\+Conj\+Limit}} \\*Conjunction of a set of limits }{\pageref{classea_1_1limit_1_1ConjLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1Crossover}{ea\+::method\+::\+Crossover}} \\*\mbox{\hyperlink{classea_1_1method_1_1Crossover}{Crossover}} method interface }{\pageref{classea_1_1method_1_1Crossover}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1DoerrMutation}{ea\+::method\+::\+Doerr\+Mutation}} \\*Doerr-\/optimized mutation }{\pageref{classea_1_1method_1_1DoerrMutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1algorithm_1_1EAAlgorithm}{ea\+::algorithm\+::\+E\+A\+Algorithm}} \\*Evolutionary (1+1) algorithm }{\pageref{classea_1_1algorithm_1_1EAAlgorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1instance_1_1Fitness}{ea\+::instance\+::\+Fitness}} \\*This structure represents Instances\textquotesingle{} fitnesses. Mathematically, it is calculated as rho $\ast$ 2$^\wedge$\{size\} + (1 -\/ \textbackslash{}rho) $\ast$ 2$^\wedge$\{pow\+\_\+nr\} }{\pageref{structea_1_1instance_1_1Fitness}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1FitnessLimit}{ea\+::limit\+::\+Fitness\+Limit}} \\*This limit controls execution by comparing best fitness with the specified limit }{\pageref{classea_1_1limit_1_1FitnessLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1FullSearch}{core\+::domain\+::\+Full\+Search}} \\*The class used to perform full search }{\pageref{classcore_1_1domain_1_1FullSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1algorithm_1_1GAAlgorithm}{ea\+::algorithm\+::\+G\+A\+Algorithm}} \\*Genetic algorithm }{\pageref{classea_1_1algorithm_1_1GAAlgorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1HordeSatSolver}{core\+::sat\+::solver\+::\+Horde\+Sat\+Solver}} }{\pageref{classcore_1_1sat_1_1solver_1_1HordeSatSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1instance_1_1Instance}{ea\+::instance\+::\+Instance}} \\*This class represents (E$\vert$G)A instance used in this project }{\pageref{classea_1_1instance_1_1Instance}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1Limit}{ea\+::limit\+::\+Limit}} \\*This is an interface for all limits that control the execution of an algorithm }{\pageref{classea_1_1limit_1_1Limit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1Mutation}{ea\+::method\+::\+Mutation}} \\*\mbox{\hyperlink{classea_1_1method_1_1Mutation}{Mutation}} interface }{\pageref{classea_1_1method_1_1Mutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1NaiveSolve}{core\+::\+Naive\+Solve}} \\*Naively solves S\+AT using the specified solver }{\pageref{classcore_1_1NaiveSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1OnePointCrossover}{ea\+::method\+::\+One\+Point\+Crossover}} \\*Standard one-\/point crossover }{\pageref{classea_1_1method_1_1OnePointCrossover}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1prop_1_1ParProp}{core\+::sat\+::prop\+::\+Par\+Prop}} \\*Parallel propagation implementation }{\pageref{classcore_1_1sat_1_1prop_1_1ParProp}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1ParRBSSolve}{core\+::\+Par\+R\+B\+S\+Solve}} \\*This class solves S\+AT in the following way\+: }{\pageref{classcore_1_1ParRBSSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1ParSolver}{core\+::sat\+::solver\+::\+Par\+Solver}} \\*Parallel solver implementation }{\pageref{classcore_1_1sat_1_1solver_1_1ParSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1PointsLimit}{ea\+::limit\+::\+Points\+Limit}} \\*This limit controls the execution by limiting the number of total (inaccurate!) points visited }{\pageref{classea_1_1limit_1_1PointsLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1Problem}{core\+::sat\+::\+Problem}} }{\pageref{classcore_1_1sat_1_1Problem}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1prop_1_1Prop}{core\+::sat\+::prop\+::\+Prop}} \\*S\+AT Propagation interface }{\pageref{classcore_1_1sat_1_1prop_1_1Prop}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1RandomSearch}{core\+::domain\+::\+Random\+Search}} \\*The class used to perform random search }{\pageref{classcore_1_1domain_1_1RandomSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1RBSSolve}{core\+::\+R\+B\+S\+Solve}} \\*This class solves S\+AT in the following way\+: }{\pageref{classcore_1_1RBSSolve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1ResourceLimit}{ea\+::limit\+::\+Resource\+Limit}} \\*This limit controls the execution by limiting time and memory consumption of an algorithm }{\pageref{classea_1_1limit_1_1ResourceLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1instance_1_1SharedData_1_1SamplingConfig}{ea\+::instance\+::\+Shared\+Data\+::\+Sampling\+Config}} \\*Sampling configuration }{\pageref{structea_1_1instance_1_1SharedData_1_1SamplingConfig}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1Search}{core\+::domain\+::\+Search}} \\*The class representing the sequential search in assignments space }{\pageref{classcore_1_1domain_1_1Search}}{}
\item\contentsline{section}{\mbox{\hyperlink{structcore_1_1domain_1_1SearchSpace}{core\+::domain\+::\+Search\+Space}} }{\pageref{structcore_1_1domain_1_1SearchSpace}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1Selector}{ea\+::method\+::\+Selector}} \\*Performs instance selection }{\pageref{classea_1_1method_1_1Selector}}{}
\item\contentsline{section}{\mbox{\hyperlink{structea_1_1instance_1_1SharedData}{ea\+::instance\+::\+Shared\+Data}} \\*This struct is shared between all instances under the same algorithm }{\pageref{structea_1_1instance_1_1SharedData}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1SimpBase}{core\+::sat\+::\+Simp\+Base}} }{\pageref{classcore_1_1sat_1_1SimpBase}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1prop_1_1SimpProp}{core\+::sat\+::prop\+::\+Simp\+Prop}} \\*Minisat\+:Simp\+Solver-\/based Solver implementation }{\pageref{classcore_1_1sat_1_1prop_1_1SimpProp}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1SimpSolver}{core\+::sat\+::solver\+::\+Simp\+Solver}} \\*Minisat\+:Simp\+Solver-\/based \mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{Solver}} implementation }{\pageref{classcore_1_1sat_1_1solver_1_1SimpSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1SingleSearch}{core\+::domain\+::\+Single\+Search}} }{\pageref{classcore_1_1domain_1_1SingleSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1Solve}{core\+::\+Solve}} \\*The core class that performs all actions related to solving S\+AT }{\pageref{classcore_1_1Solve}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{core\+::sat\+::solver\+::\+Solver}} \\*S\+AT \mbox{\hyperlink{classcore_1_1sat_1_1solver_1_1Solver}{Solver}} interface }{\pageref{classcore_1_1sat_1_1solver_1_1Solver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1limit_1_1StallLimit}{ea\+::limit\+::\+Stall\+Limit}} }{\pageref{classea_1_1limit_1_1StallLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1TwoPointCrossover}{ea\+::method\+::\+Two\+Point\+Crossover}} \\*Standard two-\/point crossover }{\pageref{classea_1_1method_1_1TwoPointCrossover}}{}
\item\contentsline{section}{\mbox{\hyperlink{classea_1_1method_1_1UniformMutation}{ea\+::method\+::\+Uniform\+Mutation}} \\*Standard uniform mutation }{\pageref{classea_1_1method_1_1UniformMutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1UniqueSearch}{core\+::domain\+::\+Unique\+Search}} \\*The class used to perform unique random search. Used for small sets of variables }{\pageref{classcore_1_1domain_1_1UniqueSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{structcore_1_1domain_1_1Vars}{core\+::domain\+::\+Vars}} \\*The class representing variables set. Variables are meant as keys in variable mapping \mbox{\hyperlink{classcore_1_1domain_1_1VarView}{core\+::domain\+::\+Var\+View}} }{\pageref{structcore_1_1domain_1_1Vars}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcore_1_1domain_1_1VarView}{core\+::domain\+::\+Var\+View}} \\*The class representing variable mapping. Is used to compactly represent mapping from a chosen set of variables, where the rest are usually ignored }{\pageref{classcore_1_1domain_1_1VarView}}{}
\end{DoxyCompactList}
